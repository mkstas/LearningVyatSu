\documentclass[a4paper,14pt]{extarticle}

\usepackage[a4paper,top=20mm,bottom=20mm,left=30mm,right=10mm]{geometry}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{fancyvrb}

\renewcommand{\baselinestretch}{1.3}

\titleformat{\section}{\normalsize\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

\setlength{\parindent}{12.5mm}

\begin{document}

\newpage\thispagestyle{empty}
\begin{center}
  \MakeUppercase{
    Министерство науки и высшего образования Российской Федерации\\
    Федеральное государственное бюджетное образовательное учреждение высшего образования\\
    <<Вятский Государственный Университет>>\\
  }
  Институт математики и информационных систем\\
  Факультет автоматики и вычислительной техники\\
  Кафедра электронных вычислительных машин
\end{center}
\vfill

\begin{center}
  Отчет по лабораторной работе №1\\
  по дисциплине\\
  <<Объектно-ориентированное программирование>>\\
\end{center}
\vfill

\noindent
\begin{tabular}{ll}
  Выполнил студент гр. ИВТб-2301-05-00 \hspace{5mm} & \rule[-1mm]{25mm}{0.10mm}\,/Макаров С.А./ \\
  Руководитель преподаватель                        & \rule[-1mm]{25mm}{0.10mm}\,/Шмакова Н.А./ \\
\end{tabular}

\vfill
\begin{center}
  Киров 2026
\end{center}

\newpage
\section*{\hspace{12.5mm}Цель работы}
Цель работы: изучить и освоить принципы объектно-ориентированного программирования, включая инкапсуляцию, наследование и полиморфизм, путем создания иерархии классов в выбранной предметной области.

\section*{\hspace{12.5mm}Задание}
\begin{enumerate}
  \item Создать иерархию классов состоящую не менее чем из одного родительского  и двух дочерних классов.
  \item В каждом классе определить не менее  двух член данных. не менее двух собственных, а для дочерних не менее двух унаследованных и двух перекрытых член функций.
  \item Разработать приложение демонстрирующее принципы инкапсуляции, наследования и полиморфизма.
\end{enumerate}

\section*{\hspace{12.5mm}Решение}
Предметная область описывает управление ассортиментом блюд в заведении общественного питания. Система позволяет хранить информацию о различных блюдах, учитывать их специфические характеристики, рассчитывать итоговую цену для клиента в зависимости от этих характеристик и выводить информацию о блюде в удобном виде.

Схема структуры иерархии классов представлена в виде диаграммы классов, представленая на рисунке 1.

\pagebreak
\begin{figure}[ht]
  \centering
  \includegraphics[width=1\linewidth]{img/uml.png}
\end{figure}
\begin{center}
  Рисунок 1 – Диаграмма классов
\end{center}

Описание меотодов классов:
\begin{itemize}
  \item[--] Класс Dish:
        \begin{itemize}
          \item[--] Dish(string name, int weight, double price) -- конструктор, инициализирует название блюда, вес в граммах и базовую цену;
          \item[--] string GetName() const -- возвращает название блюда;
          \item[--] int GetWeight() const -- возвращает вес блюда в граммах;
          \item[--] double GetPrice() const -- возвращает базовую цену блюда;
          \item[--] virtual void DisplayInfo() const -- выводит основную информацию о блюде: название, вес, итоговую цену;
          \item[] virtual double GetFullPrice() const -- возвращает цену, которую платит клиент (с наценкой);
        \end{itemize}
  \item[--] Класс Pizza наследуется от Dish:
        \begin{itemize}
          \item[--] Pizza(string name, int weight, double price) -- конструктор, передаёт параметры в базовый класс Dish, тип теста по умолчанию — Thick;
          \item[--] string GetDough() const -- возвращает текстовое описание текущего типа теста;
          \item[--] void ChangeDough() -- переключает тип теста между Thin и Thick;
          \item[--] void CutInSlices() -- имитирует действие «нарезать пиццу на куски», выводит соответствующее сообщение;
          \item[--] void DisplayInfo() const override -- переопределённый метод, выводит информацию о пицце: название, тип теста, вес, итоговая цена;
          \item[--] double GetFullPrice() const override -- возвращает итоговую цену с учётом типа теста;
        \end{itemize}
  \item[--] Класс Salad наследуется от Dish:
        \begin{itemize}
          \item[--] Salad(string name, int weight, double price) -- конструктор, передаёт параметры в базовый класс Dish, заправка по умолчанию — OliveOil;
          \item[--] string GetDressing() const -- возвращает текстовое описание текущей заправки;
          \item[--] void ChangeDressing() -- переключает вид заправки между OliveOil и Mayonnaise;
          \item[--] void TossWithDressing() const -- bмитирует действие «перемешать салат с заправкой», выводит соответствующее сообщение;
          \item[--] void DisplayInfo() const override -- gереопределённый метод, выводит информацию о салате: название, вид заправки, вес, цена;
          \item[--] double GetFullPrice() const override -- возвращает итоговую цену с учётом заправки.
        \end{itemize}
\end{itemize}

Исходный код класса Dish представлен ниже:

\noindent
\begin{Verbatim}[tabsize=4,fontsize=\small]
  #pragma once

  #include <string>
  #include <iomanip>
  #include <iostream>

  class Dish
    {
      public:
      Dish(std::string name, int weight, double price)
      : _name(std::move(name))
      , _weight(weight)
      , _price(price)
      {}

      virtual ~Dish() = default;

      std::string GetName()	const { return _name; }
      int			GetWeight() const { return _weight; }
      double		GetPrice()	const { return _price; }

      virtual void DisplayInfo() const
        {
          std::cout << "Dish: " << _name << ", "
          << _weight << "g, $"
          << std::fixed << std::setprecision(2) << GetFullPrice()
          << std::endl;
        }

      virtual double GetFullPrice() const
        {
          return _price * 1.2;
        }

      private:
      std::string _name;
      int			_weight;
      double		_price;
    };
\end{Verbatim}

Исходный код класса Pizza представлен ниже:

\noindent
\begin{Verbatim}[tabsize=4,fontsize=\small]
  #pragma once

  #include <iostream>
  #include "dish.h"

  enum Dough
    {
      Thin,
      Thick
    };

  class Pizza : public Dish
    {
      public:
      Pizza(std::string name, int weight, double price)
      : Dish(name, weight, price)
      {}

      std::string GetDough() const
        {
          return _dough == Dough::Thin ? "thin" : "thick";
        }

      void ChangeDough()
      {
          _dough = _dough == Dough::Thin ? Dough::Thick : Dough::Thin;
        }

      void CutInSlices()
      {
          std::cout << "Cutting the pizza into slices..." << std::endl;
        }

      void DisplayInfo() const override
        {
          std::cout << "Pizza: " << GetName() << ", "
          << GetDough() << " dough, "
          << GetWeight() << "g, $"
          << std::fixed << std::setprecision(2) << GetFullPrice()
          << std::endl;
        }

      double GetFullPrice() const override
        {
          return _dough == Dough::Thin ? GetPrice() * 1.3 : GetPrice() * 1.5;
        }

      private:
      Dough _dough = Dough::Thick;
    };
\end{Verbatim}

Исходный код класса Salad представлен ниже:

\noindent
\begin{Verbatim}[tabsize=4,fontsize=\small]
  #pragma once

  #include <iostream>
  #include "dish.h"

  enum Dressing
    {
      OliveOil,
      Mayonnaise
    };

  class Salad : public Dish
    {
      public:
      Salad(std::string name, int weight, double price)
      : Dish(name, weight, price)
      {}

      std::string GetDressing() const
        {
          return _dressing == Dressing::OliveOil ? "olive oil" : "mayonnaise";
        }

      void ChangeDressing()
      {
          _dressing = _dressing == Dressing::OliveOil
          ? Dressing::Mayonnaise
          : Dressing::OliveOil;
        }

      void TossWithDressing() const
        {
          std::cout << "Tossing the salad with "
          << GetDressing() << "..." << std::endl;
        }

      void DisplayInfo() const override
        {
          std::cout << "Salad: " << GetName() << ", "
          << GetDressing() << " dressing, "
          << std::to_string(GetWeight()) << "g, $"
          << std::fixed << std::setprecision(2) << GetFullPrice()
          << std::endl;
        }

      double GetFullPrice() const override
        {
          return _dressing == OliveOil ? GetPrice() * 1.4 : GetPrice() * 1.3;
        }

      private:
      Dressing _dressing = Dressing::OliveOil;
    };
\end{Verbatim}

Исходный код программы, демонстрирующее использование классов:

\noindent
\begin{Verbatim}[tabsize=4,fontsize=\small]
  #include <iostream>
  #include "dish.h"
  #include "pizza.h"
  #include "salad.h"

  int main()
  {
      Dish sushi("Philadelphia", 320, 15);
      Pizza pizza("Margarita", 450, 12);
      Salad salad("Caesar", 250, 9);

      std::cout << "--------------------------------" << std::endl;

      sushi.DisplayInfo();
      std::cout << "Full price: $" << sushi.GetFullPrice() << std::endl;

        std::cout << "--------------------------------" << std::endl;

        pizza.DisplayInfo();
        std::cout << "Full price: $" << pizza.GetFullPrice() << std::endl;
      pizza.ChangeDough();
      std::cout << "Full price: $" << pizza.GetFullPrice() << std::endl;
        pizza.CutInSlices();

        std::cout << "--------------------------------" << std::endl;

        salad.DisplayInfo();
        std::cout << "Full price: $" << salad.GetFullPrice() << std::endl;
      salad.TossWithDressing();
      salad.ChangeDressing();
      std::cout << "Full price: $" << salad.GetFullPrice() << std::endl;
      salad.TossWithDressing();

      std::cout << "--------------------------------" << std::endl;
    }
\end{Verbatim}

\section*{\hspace{12.5mm}Вывод}
В ходе выполнения лабораторной работы была разработана и реализована иерархия классов, моделирующая управление ассортиментом блюд в заведении общественного питания. Изучены основные принципы объектно-ориентированного программированя: инкапсуляция, наследование, полиморфизм. Разработано приложение, демонстрирующее применение данных принципов.

\end{document}